### Есть боевая и тестовая версия проекта.
В ходе разработки в тестовую версию проекта внесены изменения и надо эти изменения перенести на боевую версию.  

### Задача: 
Написать класс для коррекции второй бaзы данных по примеру первой. Первая БД - образец, вторая БД - которую надо скорректировать по первой БД.  Вторая БД уже существует и имеет данные, которые нельзя повредить.

### Задание:
Данную задачу должен выполнять другой сотрудник. Реализуйте данный кейс, расписав подробно ваши действия.

#######################################################################################
#######################################################################################


### Анализ:
1. Есть 2 БД.
2. Написать класс для поиска разницы между двумя схемами и/или данными в БД.
3. Данные в боевой нельзя повредить.
4. Реализовать задачу. Подробно расписать действия.

#### В задании не указаны:
1. Конкретная БД. Не уточнен тип БД.
2. Не указан тип разницы (Схема или данные). Также не указано может ли изменяться тип данных столбца.

- Предположим, что имеется ввиду Postgresql в виде одного сервера(не кластер).
- Будем считать, что есть разница только в схеме (Не будем учитывать ограничения, индексы, триггеры и т.д). ```Есть ограничения на то, что данные не должны теряться. Таким образом, задачу можно свести к добавлению новых столбцов или изменению существующих.```
- Кроме того изменение типа данных столбца может также повлечь потерю данных и потребует отдельной обработки для каждого из возможных типов. ```например integer можно преобразовать в bigint без потери данных, но в обратную сторону возникнет потеря данных.```

### Решение:

1. Чтобы сравнить две схемы, можно использовать стандартную утилиту pgAdmin `Schema Diff`. Это поможет визуализировать разницу.
2. Сделать бэкап БД: pg_dump <db_name> > /tmp/db_name.dmp
3. Развернуть БД из бэкапа, например локально.
4. Подключиться к обеим базам, стянуть схемы. Можно например сделать такой запрос и преобразовать схему в json для удобства:
```sql
SELECT c.table_name,
       json_agg(
               json_build_object(
                       'column_name', c.column_name,
                       'data_type', c.data_type,
                       'is_nullable', c.is_nullable,
                       'column_default', c.column_default,
                       'is_primary', c.column_name IN (
                            SELECT kcu.column_name
                            FROM information_schema.table_constraints tc
                            JOIN information_schema.key_column_usage kcu ON tc.constraint_name = kcu.constraint_name
                            WHERE tc.constraint_type = 'PRIMARY KEY' AND tc.table_name = c.table_name)
               ) ORDER BY c.ordinal_position
       ) AS columns
FROM information_schema.columns c
WHERE c.table_schema = 'public'
GROUP BY c.table_name
ORDER BY c.table_name;
```
5. Сравнить две схемы по следующему алгоритму:
    - Найти отсутствующие в боевой таблицы
    - Пройтись по каждой существующей таблице и проверить отсутствующие колонки
    - Найти разницу между колонками в образце и боевой
6. Сгенерировать SQL в зависимости от того, создается таблица или обновляется (CREATE или ALTER TABLE).
7. Создать транзакцию и накатить миграцию на копию БД. 
8. Проверить всё ли встало корректно (разница между обновленной копией Боевой и Боевой).
9. Накатить миграцию на боевую.

# Пример реализации лежит в репозитории...

